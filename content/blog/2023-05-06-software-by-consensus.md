---
title:  "Software by Consensus"
date:   2023-05-06
tags:
	- consensus
---

The goal of this post is to carve out some ideal types of software development projects, where decisions are made by consensus (or rough consensus). This exercise is, in part, to lay the groudwork for other posts that imagine what software development would look like in a more equitable future society, as well as to identify some projects that prefigure such an arrangement.

We will get into what making decisions by consensus means, and compare it to other forms of collective decision making below. But first, we must start with more primitive concepts.

## Projects

Human beings work on projects. The relevant concept of a project is difficult to define, but it can be characterized. First, projects are (for this discussion) a group activity. They involve participants coming together to do *something*. Second,  participants in a project come together in *good faith* to pursue their *shared interests* (although they can certainly disagree on much else). A group pursuit of shared interests forms *a collective will* to do something - in our case, create software.

This leads to an important corollary: not all groups activities are projects. For example, when a company hires someone to write some code, this does not constitute a project, because the employer and the employee do not share the same interests, and therefore do not form a collective will. The employee is at the *command* of the employer, and pursues the employer's interest in exchange for wages. In this sense, our use of the word project is idiosyncratic, but I hope not too much so.

## Participants

In the kind of software project we are interested in, a participant is anyone who has a voice in the project. In software, participants in the project are not just the developers. Participants also include users, testers, and reviewers (where a reviewer ultimately merges the proposed changes into main). 

Everyone in the community behind a project *can* play some or all the roles simultaneously. In the limit case, everyone in the community works on the project as a developer, a tester, and a reviewer -- and these same people are the only users of the software. This kind of equilibrium is uncommon simply because most of us want our software to be used widely and be put to good use. This would be impossible if we limited use of software to those who were actively developing, testing, and reviewing the software. (This kind of project need not be exclusionary: it might just so happen that no one needs the software outside the small group of people directly building it.)

## Decisions

So now we finally come to collective-decision making. We are trying to understand ways of making decisions by consensus. There are three kinds of decision making of interest, following the distinctions laid out by Andy Blunden in his [The Origins of Collective Decision-Making](https://www.haymarketbooks.org/books/998-the-origins-of-collective-decision-making), pp. TODO.

**Majoritarianism**: 

**Consensus**:

**Council**: 
